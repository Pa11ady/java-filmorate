2022-07-07 13:54:20 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "CREATE TABLE IF NOT EXISTS ratings [*]CREATE TABLE IF NOT EXISTS ratings ( rating_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name varchar(10) NOT NULL, CONSTRAINT uc_rating_name UNIQUE (name) )"
Syntax error in SQL statement "CREATE TABLE IF NOT EXISTS ratings [*]CREATE TABLE IF NOT EXISTS ratings ( rating_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name varchar(10) NOT NULL, CONSTRAINT uc_rating_name UNIQUE (name) )"; SQL statement:
CREATE TABLE IF NOT EXISTS ratings CREATE TABLE IF NOT EXISTS ratings ( rating_id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name varchar(10) NOT NULL, CONSTRAINT uc_rating_name UNIQUE (name) ) [42000-212]
2022-07-07 13:55:19 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "DROP TABLE IF [*]NOT EXISTS ratings"; ожидалось "EXISTS"
Syntax error in SQL statement "DROP TABLE IF [*]NOT EXISTS ratings"; expected "EXISTS"; SQL statement:
DROP TABLE IF NOT EXISTS ratings [42001-212]
2022-07-07 13:56:23 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Невозможно удалить "RATINGS", пока существует зависимый объект "FK_FILM_RATING_ID"
Cannot drop "RATINGS" because "FK_FILM_RATING_ID" depends on it; SQL statement:
DROP TABLE IF EXISTS ratings [90107-212]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:632)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:477)
	at org.h2.message.DbException.get(DbException.java:223)
	at org.h2.command.ddl.DropTable.prepareDrop(DropTable.java:97)
	at org.h2.command.ddl.DropTable.update(DropTable.java:121)
	at org.h2.command.CommandContainer.update(CommandContainer.java:174)
	at org.h2.command.Command.executeUpdate(Command.java:252)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:252)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:223)
	at com.zaxxer.hikari.pool.ProxyStatement.execute(ProxyStatement.java:94)
	at com.zaxxer.hikari.pool.HikariProxyStatement.execute(HikariProxyStatement.java)
	at org.springframework.jdbc.datasource.init.ScriptUtils.executeSqlScript(ScriptUtils.java:261)
	at org.springframework.jdbc.datasource.init.ResourceDatabasePopulator.populate(ResourceDatabasePopulator.java:254)
	at org.springframework.jdbc.datasource.init.DatabasePopulatorUtils.execute(DatabasePopulatorUtils.java:54)
	at org.springframework.boot.jdbc.init.DataSourceScriptDatabaseInitializer.runScripts(DataSourceScriptDatabaseInitializer.java:90)
	at org.springframework.boot.sql.init.AbstractScriptDatabaseInitializer.runScripts(AbstractScriptDatabaseInitializer.java:145)
	at org.springframework.boot.sql.init.AbstractScriptDatabaseInitializer.applyScripts(AbstractScriptDatabaseInitializer.java:107)
	at org.springframework.boot.sql.init.AbstractScriptDatabaseInitializer.applySchemaScripts(AbstractScriptDatabaseInitializer.java:97)
	at org.springframework.boot.sql.init.AbstractScriptDatabaseInitializer.initializeDatabase(AbstractScriptDatabaseInitializer.java:75)
	at org.springframework.boot.sql.init.AbstractScriptDatabaseInitializer.afterPropertiesSet(AbstractScriptDatabaseInitializer.java:65)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1863)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1800)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:620)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)
	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1154)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:908)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:147)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:408)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:308)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1306)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1295)
	at ru.yandex.practicum.filmorate.FilmorateApplication.main(FilmorateApplication.java:9)
2022-07-07 14:39:10 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Синтаксическая ошибка в выражении SQL "MERGE INTO [*]KEY (rating_id) VALUES (1, 'G'), (2, 'PG'), (3, 'PG-13'), (4, 'R'), (5, 'NC-17')"; ожидалось "identifier"
Syntax error in SQL statement "MERGE INTO [*]KEY (rating_id) VALUES (1, 'G'), (2, 'PG'), (3, 'PG-13'), (4, 'R'), (5, 'NC-17')"; expected "identifier"; SQL statement:
MERGE INTO KEY (rating_id) VALUES (1, 'G'), (2, 'PG'), (3, 'PG-13'), (4, 'R'), (5, 'NC-17') [42001-212]
